
1. 计算机算数
2. 程序在机器上如何表示
3. 组合和时序逻辑组合到一起来表示IA32指令集的一个称为“Y86”的简化子集。
4. 提高代码性能的技术


操作系统的设计，因此可以归结为三点：  
（1）以多进程形式，允许多个任务同时运行；  
（2）以多线程形式，允许单个任务分成不同的部分运行；  
（3）提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。
   
### 信息存储 ###
机器级程序将存储器视为一个非常大的字节数组，称为存储虚拟器。存储器的每个字节都由一个唯一的数字来标示，称为它的**地址**，所有可能的地址的集合称为虚拟地址空间。  

1.程序员必须要使他们的程序在不停地机器和编译器上可移植。可移植性的一 个方面是使程序对不同类型的确切大小不敏感。 

**移位运算：** 逻辑移位，算数移位。  
逻辑右移，在左端补k个0。算数右移，在左端补上k个最高有效位的拷贝。  
对于无符号数，右移必须是逻辑的。几乎所有的编译器对有符号数据实施算数右移。  
**整数表示：**几乎所有的机器用二进制补码的形式来表示有符号整数。  
为什么有些时候，两个整数相加会产生一个负数，比较表达式x<y与x-y<0会产生不同的影响。  
**浮点：**十进制符号不能精确地表示1/3,5/7这样的数。而小数的二进制表示法只能表示那些能被写成x*2的y次方的形式。IEEE浮点标准用V=(-1)^s*M*2^E的形式来表示一个数。（一个单独的符号位直接编码符号s;k位的指数域exp编码指数E;n位的小数域frac编码有效数M。在单精度浮点格式（C语言中的float），s,exp,frac分别为1,8,23,位。双精度浮点格式中（C语言的double），s,exp,frac分别为1,11,52.  
**解释为什么8位有符号数范围是-128——127**  
-127 11111111 补码10000001  
-128 10000000 补码10000000  
0 00000000    补码00000000  
1 00000001    补码00000001
 
#### 对C语言程序员隐藏的处理器状态 ####
**程序计数器**：要执行的下一条指令在存储器中的位置。  
**整数寄存器**：存储地址或整数数据  
**条件码寄存器**：最近执行的算数或逻辑指令的信息  
**浮点寄存器**：存放浮点数据

C语言提供了一种模型，可以在存储器中声明和分配各种数据类型的对象，但是机器代码只是将存储器视为一个很大的，按字节寻址的数组。

操作数分为3种：立即数，寄存器，存储器。


### 过程 ###

程序寄存器组是唯一可以被所有过程共享的资源。依据惯例，寄存器%eax %edx %ecx被划分为**调用者保护寄存器**，过程P调用Q时，Q可以覆盖这些寄存器，而不会破坏任何P所需要的数据。另一方面，%ebx,%esi,%edi被划分为**被调用者保护寄存器**，Q必须在覆盖这些寄存器之前，先把他们保存到栈中去，并在返回前恢复他们。

IA32程序用**程序栈**来支持过程调用。机器用栈来传递过程参数，存储返回信息，保存寄存器用于以后恢复，以及本地存储，  
为单个过程分配的那部分栈称为**栈帧**。栈帧结构如下：  
![](E:\markdown_picture\栈帧结构.png)

## 存储器层次结构 ##
存储器层次结构对于应用程序的性能有重大影响。  
访问一个磁盘扇区的512个字节的时间主要是寻道时间和旋转延迟，访问扇区中的第一个字节用了很长时间，但是访问剩下的字节几乎不用时间。  
寻道时间和旋转延迟基本相等。

一个编写良好的计算机程序具有良好的局部性。**其倾向于引用邻近于其他最近引用过的数据项的数据项，或者最近引用的数据项本身**  
良好的时间局部性：被引用过一次的存储器位置可能在不远的将来再次多次引用。  
空间局部性：一个存储器位置被引用了一次，程序可能在不远的将来引用附近的一个存储器位置。


中心思想：层析结构中的每一层都缓存来自于较低一层的数据对象。  
![](E:\markdown_picture\存储器层次结构缓存原理.png)   
**缓存命中：**当程序需要第k+1层的某个数据对象d，他首先从存储在第k层的一个快中查找d，如果d刚好在，那么即缓存命中。**如果缓存不命中，**第k层缓存从第k+1层取出包含d的那个块，如果第k层已经满了，可能会覆盖现有的块。  
**不命中的分类：冷不命中，冲突不命中，容量不命中**    
高速缓存总线结构：  
![](E:\markdown_picture\高速缓存总线结构.png) 

根据E，高速缓存被分为不同的类。每个组只有一行的高速缓存被称为**直接映射高速缓存**。  
3步走：**组选择，行匹配，字抽取**  
如果有效位没有设置，或者标记不相匹配，我们得到一个**缓存不命中。**  
直接映射高速缓存：  
（S,E,B，m）=(4,1,2,4)  
高速缓存4个组，每组1行，每个块2个字节，地址是4位的。

**抖动的出现与消除**  
**组相连高速缓存**
组相连高速缓存的行匹配比直接映射高速缓存中的更复杂，其必须检查多个行的标记位和有效位。
组中任何一行都可以包含任何映射到这个组的存储器块。  
组相连高速缓存：  
![](E:\markdown_picture\组相连高速缓存.png)   
全相连高速缓存：  
![](E:\markdown_picture\全相连高速缓存.png)  
全相连高速缓存只适合做小的高速缓存。

高速缓存关于读的操作：  
1.在高速缓存中查找所需字w的拷贝，如果命中，立即返回字w给CPU，如果没有命中，从存储器较低层中取出包含字w的块，将这个块存储到某个高速缓存行中去。  
关于写的操作：  
写回缓存：与读的方式对称，写回写分配也试图利用局部性。  

![](E:\markdown_picture\interlcorei7的高速缓存层次结构.png)  
较大的高速缓存可能会提高命中率，但是会增加命中时间。  
较大的块可以提升利用空间局部性的能力，但是对于给定的高速缓存大小，快越大意味着高速缓存行数越小，这会损害时间局部性。  

酷睿i7存储器山：  
![](E:\markdown_picture\酷睿i7存储器山.png)   
存储器的性能不是一个数字可以描述的，相反，它是一座时间和空间局部性的山，这座山的上升高度差别可以超过一个数量级。好的程序员要利用时间局部性，使频繁的字从L1取出，利用空间局部性，使尽可能多的字从L1高速缓存中访问得到。


### 链接 ###

链接是将各种代码和数据部分收集起来并组合成一个单一文件的过程。

**理解链接器帮助你构造大型程序，帮助你理解语言的作用域规则如何实现**  
![](E:\markdown_picture\静态链接.png) 
为构造可执行文件，链接器主要完成**符号解析和重定位**  
编译器和汇编器生成可重定位目标文件，链接器生成可执行目标文件。  
#### 链接器如何解析多重定义的全局符号 ####
在示例程序中，bufp1,swap,,ain,buf是强符号，bufp1是弱符号。

我们通常习惯假设链接器读取一组可重定位目标文件，并将它们链接起来，成为一个输出的可执行文件。所有的编译系统也提供一种机制，将所有相关的目标模块打包为一个单独的文件，成为静态库。  
如果不使用静态库的话，编译器让编译器辨认出是对标准函数的调用，并直接生成相应的代码。另一个方法是把所有的标准C函数都放在一个单独的可重定位的目标模块中，这种缺点是系统的每个人可执行文件都包含一份标准函数集合的完整拷贝，这对磁盘空间是很大的浪费。都标准函数的任何小的改变，库的开发人员都要重新编译这个源文件，这是一个很耗时的操作。   
静态库可以解决以上问题，相关的函数可以被编译为独立的目标模块，然后封装为一个独立的静态库文件。
#### 链接器如何使用静态库来解析引用 ####

#### 重定位 ####
一旦链接器完成了符号解析，它就把代码中的每个符号引用和确定的一个符号定义联系起来。

**有点看不懂**


## 异常控制流 ##

现代系统通过使控制流发生突变来做出反应，这些突变被称为**异常控制流（Exceptional Control Flow）ECF**。  


1. ECF是操作系统来实现I/O、进程和虚拟内存的基本机制。
2. 应用程序通过使用一个叫陷阱（trap）或者是系统调用（system call）的ECF形式，向操作系统请求服务。
3. ECF是计算机系统实现并发的基本机制

应用与操作系统的交互都是围绕着ECF的。  

异常即控制流中的突变，用来响应处理器状态中的某些变化。在任何情况下，当处理器检测到有事件发生时，它会通过一张叫做异常表的跳转表，进行一个间接过程调用，到一个专门设计用来处理这类事件的操作系统子程序。  
**中断**（异步发生）        
![](E:\markdown_picture\中断处理.png)  
结果程序继续执行，就好像没有中断一样。  
**陷阱，故障，终止**（同步发生）   
陷阱是有意的异常，是执行一条指令的结果。陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫做**系统调用**。    
![](E:\markdown_picture\陷阱处理.png)  
故障处理：  
![](E:\markdown_picture\故障处理.png)     
终止处理：   
![](E:\markdown_picture\终止处理.png)    

#### 进程 ####
异常是允许操作系统提供进程的概念所需的基本构造块。进程给我们展现了很多的假象：我们的程序是系统中唯一运行的程序，我们的程序独占处理器和存储器......  
系统的每个程序都是运行在某个进程上的上下文中的，上下文有程序正确运行所需的状态组成，这个状态包括存放在存储器中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。  进程提供给应用程序的关键抽象：**一个独立的逻辑控制流(好像我们的程序独占处理器)，一个私有的地址空间（好像我们的程序独占存储器系统）**    
**逻辑控制流**  
多个流并发地执行被称为并发，一个进程和其他进程轮流运行的概念叫做多任务。**如果两个流并发地运行在不同的处理器核或计算机上，我们称其为并行流。**  

处理器通常使用某个控制寄存器的一个模式位来提供这种功能。一个运行在内核模式的进程可以执行指令集中的任何指令，并且可以访问系统中任何存储器的位置。  
在用户模式时，用户程序必须通过系统调用接口间接访问内核代码和数据。  
进程是执行中程序的一个具体的实例。程序总是运行在某个进程的上下文中的。  
**fork函数**——在新的子程序中运行与父进程相同的程序，**execve函数**——在当前的进程上下文中加载并运行一个新的程序，它会覆盖当前进程的地址空间。
fork一次调用，返回2次。execve一次调用从不返回。

#### 上下文切换 ####
实现多任务。 

1. 保存当前进程的上下文
2. 恢复某个先前被抢占的进程保存的上下文
3. 将控制传递给这个新回复的进程

定时器中断：内核判定当前进程已经运行了足够的时间。   
进程上下文切换剖析：    
![](E:\markdown_picture\进程上下文切换剖析.png)


从程序员的角度，我们认为进程总是处于下面三种状态之一：  
运行 停止（进程挂起） 终止  
创建的子进程几乎但不完全与父进程相同，虚拟地址空间的拷贝，包括文本，数据和bss段，堆以及用户栈。  
理解fork：  
![](E:\markdown_picture\fork创建新的进程.png)  
共享文件，父进程和子进程都把输出显示在屏幕上，子进程继承了父进程所有打开的文件，父进程调用fork时，stdout文件是被打开的，子进程继承了这个文件，它的输出也只想屏幕。  
**回收子进程**  
一个终止了但是还没有被回收的进程称为僵死进程。 
#### 信号 ####
发送一个信号到目的进程分两步：



1. 发送信号 内核通过更新目的进程上下文中的某个状态，发送一个信号给目的进程。
2. 接收信号 目的进程被内核强迫一某种方式对信号的发送做出反应时，目的进程就接收了信号。

![](E:\markdown_picture\进程信号处理.png) 
  
![](E:\markdown_picture\fork创建新的进程.png)
Unix系统提供了大量向进程发送信号的机制，所有的这些机制都是基于**进程组**这个概念的。  
信号处理程序是计算机系统中并发的一个示例。信号处理程序的执行中断mainC函数的执行，类似于底层异常处理程序中断当前应用程序的控制流的方式，因为信号处理程序的逻辑控制流与主函数的逻辑控制流重叠，信号处理程序和主函数并发运行。


## 虚拟存储器 ##
现代系统提供了一种对主存的抽象概念，叫做虚拟存储器。虚拟存储器是硬件异常，硬件地址翻译，主存，磁盘空间以及内核软件的完美交互，他为每一个进程提供一个大的、一致的和私有的地址空间。虚拟存储器提供了3个重要的能力：

1. 将主存看做一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，这样可以高效使用主存。
2. 为每个进程提供了一致的地址空间，简化了存储管理。
3. 保护了每个进程的地址空间不被破坏。

虚拟存储器是计算机系统最重要的概念之一

1. 在硬件异常，汇编器，链接器，加载器，共享对象，文件和进程的设计中扮演重要的角色。
2. 虚拟存储器给予了应用程序强大的能力；可以创建和销毁存储器片。将存储器片映射到磁盘文件的某个部分，与其他进程共享存储器。
3. 虚拟存储器是危险的。一个带有指针错误的程序可以立即崩溃于段错误或者保护错误，也可能产生错误的结果。  


虚拟寻址系统示意图：  
![](E:\markdown_picture\虚拟寻址.png)  

主存的每个字节都有一个选自虚拟地址空间的虚拟地址和一个选自物理地址空间的物理地址。  
虚拟存储器被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。每字节都有一个唯一的虚拟地址。

虚拟存储器提供一种机制，利用DRAM缓存来自通常更大的虚拟地址空间的页面。操作系统为每个进程提供一个独立的页表，也就是一个独立的虚拟地址空间。**按需页面调度和独立的内存地址空间的结合对系统中存储器的使用和管理带来了深远影响，VM简化了链接和加载，代码和数据共享以及应用程序的存储器分配**。

![](E:\markdown_picture\VM为进程提供独立的地址空间.png) 

![](E:\markdown_picture\页面命中和缺页操作.png) 

![](E:\markdown_picture\VM为进程提供独立的地址空间.png)   

页面命中处理：  

1. 处理器生成一个虚拟地址，将它传给MMU(内存管理单元)
2. MMU生成PTE地址，并从高速缓存/主存得到它
3. 高速缓存/主存向MMU返回PTE
4. MMU构造物理地址，并将它传送给高速缓存/主存
5. 高速缓存/主存返回所请求的数据字给处理器

页面缺页处理：

1. 处理器生成一个虚拟地址，将它传给MMU(内存管理单元)
2. MMU生成PTE地址，并从高速缓存/主存得到它
3. 高速缓存/主存向MMU返回PTE
4. PTE的有效位为0，MMU触发一次异常，传递CPU的控制到操作系统内核中的缺页异常处理程序
5. 缺页处理程序确定出物理存储器中的牺牲页，如果这个页面已经被修改，则把它换出到磁盘。
6. 缺页处理程序页面调入新的页面，更新存储器中的PTE\
7. 缺页处理程序返回原来的进程，再次执行导致缺页的指令。CPU将引起缺页的虚拟地址重新发送给MMU。

在任何既使用虚拟存储器又使用SRAM高速缓存的系统中，都存在应该使用物理地址还是虚拟地址访问SRAM高速缓存的问题。大多数系统选择物理寻址。  

**利用TLB加速地址翻译：**

![](E:\markdown_picture\TLB加速地址翻译.png) 

**多级列表：**

32位的地址空间，4KB的页面，4字节的PTE：需要4MB的页表驻留在存储器中。

#### intel core i7/Linux 存储器系统 ####
一个运行Linux的Intel core i7。

![](E:\markdown_picture\Inteli7存储器系统.png)


![](E:\markdown_picture\Corei7地址翻译.png)

#### linux虚拟存储器系统 ####

![](E:\markdown_picture\一个Linux进程的虚拟存储器.png) 

Linux组织虚拟存储器的方法：

![](E:\markdown_picture\Linux组织虚拟存储器的方法.png) 

#### 存储器映射 ####
Linux通过将一个虚拟存储器区域与一个磁盘上的对象关联起来，以初始化这个虚拟存储器区域的内容——存储器映射  

#### 动态存储器分配 ####
分配器的设计在最大化吞吐率和最大化存储器利用率之间找到一个平衡。造成堆利用率很低的主要原因是一种称为碎片的现象，当虽然有未使用的存储器但不能满足分配要求时，会发生这种现象。
内部碎片：已分配快比有效载荷大时发生。（为了满足对齐约束条件）  
外部碎片：当空闲存储器合计起来足够满足一个分配请求，但是没有一个单独的空闲块足够大可以来处理这个请求时发生。

构造一个分配器是一件富有挑战的任务，设计空间很大，有许多块格式、空闲链表格式以及放置、分割和合并策略可供选择。

#### 基于隐式空闲列表，使用立即边界标记合并方式，实现一个简单的分配器 ####

#### 垃圾收集 ####
垃圾收集器是一种动态存储分配器，他自动释放程序不再需要的已分配块，这些块称为垃圾。

垃圾收集器将存储器视为一张有向可达图，在任何时刻，不可达节点对应于垃圾，是不能被应用再次使用的。垃圾收集器可以维护可达图的某种表示，并通过释放不可达节点将他们返回给空闲列表，来定期回收它们。

## 系统级I/O ##
在**主存和外部设备**之间拷贝数据的过程。所有的语言都提供了执行I/O的较高级别的工具。ANSI C提供标准I/O库，包括printf和scanf这样执行带缓冲区的I/O函数，C++使用重载操作符<<(输入)和>>(输出)提供类似的功能。在Unix，使用由内核提供的系统级UnixI/O函数来实现这些高级别函数。  
一个Unix文件是一个m个字节的序列：B0 B1 B2 ... Bm-1  
所有的I/O设备，如网络，磁盘和终端，都被模型化为文件，而所有的输入和输出都被当做对相应文件的读和写来执行。    

**打开文件：**一个应用程序要求内核打开相应的文件，来宣告它要访问一个I/O设备。**关闭文件：**通知内核关闭文件，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止，内核会关闭所有打开的文件并释放它们的存储器资源。  
通过调用rio_readn和rio_writen函数，应用程序可以在存储器和文件之间传送数据。









